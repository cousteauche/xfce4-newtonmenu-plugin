/* Generated by LLM - DO NOT EDIT */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <gtk/gtk.h>
#include <libxfce4util/libxfce4util.h>
#include <libxfce4panel/libxfce4panel.h>
#include <gdk/gdkkeysyms.h>
#include <libintl.h>

// New includes for global menu functionality
#include <libwnck/libwnck.h>
#include <gio/gio.h>
#include <dbusmenu-glib/client.h> // For DbusmenuClient_new, etc.


#include "newtonmenu.h"
#include "newtonmenu-dialogs.h" 
#include "newtonmenu-force-quit-dialog.h"

// Constants
#define DEFAULT_DISPLAY_ICON TRUE
#define DEFAULT_ICON_NAME "xfce4-newtonmenu-plugin"
#define DEFAULT_LABEL_TEXT N_("Menu")

#define DEFAULT_CONFIRM_LOGOUT FALSE
#define DEFAULT_CONFIRM_RESTART TRUE
#define DEFAULT_CONFIRM_SHUTDOWN TRUE
#define DEFAULT_CONFIRM_FORCE_QUIT FALSE 

// New global menu default properties
#define DEFAULT_HIDE_APPLICATION_NAME FALSE
#define DEFAULT_GLOBAL_MENU_TITLE N_("Applications") // Default title when app name hidden

// D-Bus constants for AppMenu Registrar
#define APPMENU_REGISTRAR_BUS_NAME "com.canonical.AppMenu.Registrar"
#define APPMENU_REGISTRAR_OBJECT_PATH "/com/canonical/AppMenu/Registrar"
#define APPMENU_REGISTRAR_INTERFACE_NAME "com.canonical.AppMenu.Registrar"


// Forward declarations for internal functions
static void newtonmenu_construct (XfcePanelPlugin *plugin);
static void newtonmenu_read (newtonmenuPlugin *newtonmenu);
static void newtonmenu_free (XfcePanelPlugin *plugin, newtonmenuPlugin *newtonmenu);
static void newtonmenu_orientation_changed (XfcePanelPlugin *plugin, GtkOrientation orientation, newtonmenuPlugin *newtonmenu);
static gboolean newtonmenu_size_changed (XfcePanelPlugin *plugin, gint size, newtonmenuPlugin *newtonmenu);
static newtonmenuPlugin* newtonmenu_new (XfcePanelPlugin *plugin);
// This function becomes a no-op or handles autohide due to GtkMenuButton usage
static void newtonmenu_popup_menu_on_toggle (GtkMenuButton *button, newtonmenuPlugin *newtonmenu); 
static void newtonmenu_menu_deactivate_cb (GtkMenuButton *button, newtonmenuPlugin *newtonmenu); 


static void on_about_this_pc_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_system_settings_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_run_command_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_force_quit_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_sleep_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_restart_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_shutdown_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_lock_screen_activate(GtkMenuItem *menuitem, gpointer user_data);
static void on_log_out_activate(GtkMenuItem *menuitem, gpointer user_data);

static void execute_command(const gchar *command);

// New forward declarations for global menu integration
static void newtonmenu_init_dbus_and_wnck(newtonmenuPlugin *newtonmenu);
static void newtonmenu_teardown_dbus_and_wnck(newtonmenuPlugin *newtonmenu);
static void on_wnck_active_window_changed (WnckScreen *screen, WnckWindow *prev_active_window, newtonmenuPlugin *newtonmenu);
static void on_appmenu_registrar_signal (GDBusProxy *proxy, const gchar *sender_name, const gchar *signal_name, GVariant *parameters, gpointer user_data); // Changed user_data to gpointer to match G_CALLBACK signature
static void newtonmenu_fetch_app_menu (newtonmenuPlugin *newtonmenu, WnckWindow *window);
static GMenu* newtonmenu_create_static_newton_menu(newtonmenuPlugin *newtonmenu);
static GMenuModel* newtonmenu_create_desktop_menu_model(void);


XFCE_PANEL_PLUGIN_REGISTER (newtonmenu_construct);


static void execute_command(const gchar *command)
{
    GError *error = NULL;
    if (!g_spawn_command_line_async (command, &error))
    {
        g_warning ("Failed to execute command '%s': %s", command, error ? error->message : "Unknown error");
        if (error) g_error_free (error);
    }
}

void
newtonmenu_save (XfcePanelPlugin *plugin,
             newtonmenuPlugin    *newtonmenu)
{
  XfceRc *rc;
  gchar  *file;

  g_return_if_fail(newtonmenu != NULL);
  g_return_if_fail(XFCE_IS_PANEL_PLUGIN(plugin));

  file = xfce_panel_plugin_save_location (plugin, TRUE);

  if (G_UNLIKELY (file == NULL))
    {
       return;
    }

  rc = xfce_rc_simple_open (file, FALSE);
  g_free (file);

  if (G_LIKELY (rc != NULL))
    {
      xfce_rc_write_bool_entry (rc, "DisplayIcon", newtonmenu->display_icon_prop);
      // Save new global menu properties
      xfce_rc_write_bool_entry (rc, "HideApplicationName", newtonmenu->hide_application_name_prop);
      if (newtonmenu->global_menu_title_prop)
        xfce_rc_write_entry (rc, "GlobalMenuTitle", newtonmenu->global_menu_title_prop);
      else
        xfce_rc_write_entry (rc, "GlobalMenuTitle", "");

      if (newtonmenu->icon_name_prop)
        xfce_rc_write_entry (rc, "IconName", newtonmenu->icon_name_prop);
      else
        xfce_rc_write_entry (rc, "IconName", "");

      if (newtonmenu->label_text_prop)
        xfce_rc_write_entry (rc, "LabelText", newtonmenu->label_text_prop);
      else
        xfce_rc_write_entry (rc, "LabelText", "");
      
      xfce_rc_write_bool_entry(rc, "ConfirmLogout", newtonmenu->confirm_logout_prop);
      xfce_rc_write_bool_entry(rc, "ConfirmRestart", newtonmenu->confirm_restart_prop);
      xfce_rc_write_bool_entry(rc, "ConfirmShutdown", newtonmenu->confirm_shutdown_prop);
      xfce_rc_write_bool_entry(rc, "ConfirmForceQuit", newtonmenu->confirm_force_quit_prop);

      xfce_rc_close (rc);
    }
}

static void
newtonmenu_read (newtonmenuPlugin *newtonmenu)
{
  XfceRc      *rc;
  gchar       *file;
  const gchar *value;

  g_return_if_fail(newtonmenu != NULL);
  g_return_if_fail(newtonmenu->plugin != NULL);

  file = xfce_panel_plugin_save_location (newtonmenu->plugin, TRUE);

  if (G_LIKELY (file != NULL))
    {
      rc = xfce_rc_simple_open (file, TRUE);
      g_free (file);

      if (G_LIKELY (rc != NULL))
        {
          newtonmenu->display_icon_prop = xfce_rc_read_bool_entry (rc, "DisplayIcon", DEFAULT_DISPLAY_ICON);
          // Read new global menu properties
          newtonmenu->hide_application_name_prop = xfce_rc_read_bool_entry (rc, "HideApplicationName", DEFAULT_HIDE_APPLICATION_NAME);
          value = xfce_rc_read_entry (rc, "GlobalMenuTitle", _(DEFAULT_GLOBAL_MENU_TITLE));
          g_free(newtonmenu->global_menu_title_prop);
          newtonmenu->global_menu_title_prop = g_strdup (value);


          value = xfce_rc_read_entry (rc, "IconName", DEFAULT_ICON_NAME);
          g_free(newtonmenu->icon_name_prop);
          newtonmenu->icon_name_prop = g_strdup (value);

          value = xfce_rc_read_entry (rc, "LabelText", _(DEFAULT_LABEL_TEXT));
          g_free(newtonmenu->label_text_prop);
          newtonmenu->label_text_prop = g_strdup (value);
          
          newtonmenu->confirm_logout_prop = xfce_rc_read_bool_entry(rc, "ConfirmLogout", DEFAULT_CONFIRM_LOGOUT);
          newtonmenu->confirm_restart_prop = xfce_rc_read_bool_entry(rc, "ConfirmRestart", DEFAULT_CONFIRM_RESTART);
          newtonmenu->confirm_shutdown_prop = xfce_rc_read_bool_entry(rc, "ConfirmShutdown", DEFAULT_CONFIRM_SHUTDOWN);
          newtonmenu->confirm_force_quit_prop = xfce_rc_read_bool_entry(rc, "ConfirmForceQuit", DEFAULT_CONFIRM_FORCE_QUIT);
          
          xfce_rc_close (rc);
          return;
        }
    }

  newtonmenu->display_icon_prop = DEFAULT_DISPLAY_ICON;
  newtonmenu->hide_application_name_prop = DEFAULT_HIDE_APPLICATION_NAME;

  g_free(newtonmenu->icon_name_prop);
  newtonmenu->icon_name_prop = g_strdup (DEFAULT_ICON_NAME);
  g_free(newtonmenu->label_text_prop);
  newtonmenu->label_text_prop = g_strdup (_(DEFAULT_LABEL_TEXT));
  g_free(newtonmenu->global_menu_title_prop);
  newtonmenu->global_menu_title_prop = g_strdup (_(DEFAULT_GLOBAL_MENU_TITLE));

  newtonmenu->confirm_logout_prop = DEFAULT_CONFIRM_LOGOUT;
  newtonmenu->confirm_restart_prop = DEFAULT_CONFIRM_RESTART;
  newtonmenu->confirm_shutdown_prop = DEFAULT_CONFIRM_SHUTDOWN;
  newtonmenu->confirm_force_quit_prop = DEFAULT_CONFIRM_FORCE_QUIT;
}

void
newtonmenu_update_display (newtonmenuPlugin *newtonmenu)
{
    GtkIconTheme *icon_theme = NULL;
    gint panel_icon_size;

    g_return_if_fail (newtonmenu != NULL);
    g_return_if_fail (newtonmenu->plugin != NULL);
    g_return_if_fail (GTK_IS_MENU_BUTTON (newtonmenu->button)); // Changed to GtkMenuButton
    g_return_if_fail (GTK_IS_BOX (newtonmenu->button_box));
    g_return_if_fail (GTK_IS_IMAGE (newtonmenu->icon_image));
    g_return_if_fail (GTK_IS_LABEL (newtonmenu->label_widget));

    if (newtonmenu->display_icon_prop)
    {
        gtk_widget_show (newtonmenu->icon_image);
        gtk_widget_hide (newtonmenu->label_widget);

        icon_theme = gtk_icon_theme_get_for_screen (gtk_widget_get_screen (GTK_WIDGET (newtonmenu->plugin)));
        panel_icon_size = xfce_panel_plugin_get_icon_size (newtonmenu->plugin);
        
        if (newtonmenu->icon_name_prop && strlen(newtonmenu->icon_name_prop) > 0) {
            if (gtk_icon_theme_has_icon(icon_theme, newtonmenu->icon_name_prop)) {
                 gtk_image_set_from_icon_name (GTK_IMAGE (newtonmenu->icon_image),
                                          newtonmenu->icon_name_prop,
                                          GTK_ICON_SIZE_BUTTON);
                 gtk_image_set_pixel_size(GTK_IMAGE(newtonmenu->icon_image), panel_icon_size);
            } else if (g_file_test(newtonmenu->icon_name_prop, G_FILE_TEST_IS_REGULAR)) {
                GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file_at_size(newtonmenu->icon_name_prop, panel_icon_size, panel_icon_size, NULL);
                if (pixbuf) {
                    gtk_image_set_from_pixbuf(GTK_IMAGE(newtonmenu->icon_image), pixbuf);
                    g_object_unref(pixbuf);
                } else {
                    gtk_image_set_from_icon_name (GTK_IMAGE (newtonmenu->icon_image), "image-missing", GTK_ICON_SIZE_BUTTON);
                    gtk_image_set_pixel_size(GTK_IMAGE(newtonmenu->icon_image), panel_icon_size);
                }
            } else {
                 gtk_image_set_from_icon_name (GTK_IMAGE (newtonmenu->icon_image), "image-missing", GTK_ICON_SIZE_BUTTON);
                 gtk_image_set_pixel_size(GTK_IMAGE(newtonmenu->icon_image), panel_icon_size);
            }
        } else {
             gtk_image_set_from_icon_name (GTK_IMAGE (newtonmenu->icon_image), "image-missing", GTK_ICON_SIZE_BUTTON);
             gtk_image_set_pixel_size(GTK_IMAGE(newtonmenu->icon_image), panel_icon_size);
        }
    }
    else
    {
        gtk_widget_hide (newtonmenu->icon_image);
        gtk_widget_show (newtonmenu->label_widget);
        gtk_label_set_text (GTK_LABEL (newtonmenu->label_widget), 
                            newtonmenu->label_text_prop ? _(newtonmenu->label_text_prop) : "");
    }

    gtk_widget_queue_resize (GTK_WIDGET(newtonmenu->plugin));
}

static newtonmenuPlugin *
newtonmenu_new (XfcePanelPlugin *plugin)
{
  newtonmenuPlugin   *newtonmenu;
  GtkOrientation  orientation;

  newtonmenu = g_slice_new0 (newtonmenuPlugin);
  newtonmenu->plugin = plugin;
  newtonmenu_read (newtonmenu);

  orientation = xfce_panel_plugin_get_orientation (plugin);

  newtonmenu->event_box = gtk_event_box_new ();
  gtk_widget_show (newtonmenu->event_box);

  // Use GtkMenuButton instead of GtkToggleButton for dynamic menu model binding
  newtonmenu->button = GTK_MENU_BUTTON(gtk_menu_button_new ()); 
  gtk_button_set_relief (GTK_BUTTON (newtonmenu->button), GTK_RELIEF_NONE);
  gtk_widget_show (GTK_WIDGET(newtonmenu->button)); // Cast to GtkWidget for show/hide

  // The button_box is still needed for icon/label display within the menu button
  newtonmenu->button_box = gtk_box_new (orientation, 2);
  gtk_container_set_border_width(GTK_CONTAINER(newtonmenu->button_box), 2);
  gtk_widget_show (newtonmenu->button_box);
  gtk_container_add (GTK_CONTAINER (newtonmenu->button), newtonmenu->button_box);

  newtonmenu->icon_image = gtk_image_new ();
  gtk_box_pack_start (GTK_BOX (newtonmenu->button_box), newtonmenu->icon_image, FALSE, FALSE, 0);

  newtonmenu->label_widget = gtk_label_new ("");
  gtk_box_pack_start (GTK_BOX (newtonmenu->button_box), newtonmenu->label_widget, TRUE, TRUE, 0);
  
  newtonmenu_update_display (newtonmenu);
  
  // Initialize global menu related components
  newtonmenu->static_newton_menu = newtonmenu_create_static_newton_menu(newtonmenu);
  newtonmenu->app_menu_model = NULL;
  newtonmenu->combined_menu_model = NULL;
  
  newtonmenu_init_dbus_and_wnck(newtonmenu); // Starts listening for app menus
  // Initial menu composition will be triggered by on_wnck_active_window_changed after wnck init.
  // We still call it here to ensure the combined_menu_model is initially set.
  newtonmenu_update_combined_menu(newtonmenu); 

  // Connect to GtkMenuButton's "map" and "unmap" signals to block/unblock autohide
  // These are connected in `newtonmenu_construct` now for more reliable signal handling.
  // We remove the duplicate connections here to ensure they are connected only once.
  // No, actually, for `xfce_panel_plugin_add_action_widget`, it's better to connect in construct
  // since `newtonmenu->button` is added to `newtonmenu->event_box` which is then added as action widget.
  // So, the connects in `newtonmenu_construct` are the primary ones.

  return newtonmenu;
}

static void
newtonmenu_free (XfcePanelPlugin *plugin,
             newtonmenuPlugin    *newtonmenu)
{
  GtkWidget *dialog;

  g_return_if_fail(newtonmenu != NULL);

  dialog = g_object_get_data (G_OBJECT (plugin), "dialog");
  if (G_UNLIKELY (dialog != NULL))
    gtk_widget_destroy (dialog);

  g_free (newtonmenu->icon_name_prop);
  newtonmenu->icon_name_prop = NULL;
  g_free (newtonmenu->label_text_prop);
  newtonmenu->label_text_prop = NULL;
  g_free (newtonmenu->global_menu_title_prop);
  newtonmenu->global_menu_title_prop = NULL;

  // Release global menu related resources
  if (newtonmenu->static_newton_menu)
      g_object_unref(newtonmenu->static_newton_menu);
  if (newtonmenu->app_menu_model)
      g_object_unref(newtonmenu->app_menu_model);
  if (newtonmenu->combined_menu_model)
      g_object_unref(newtonmenu->combined_menu_model);
  
  newtonmenu_teardown_dbus_and_wnck(newtonmenu);
  
  g_slice_free (newtonmenuPlugin, newtonmenu);
}

static void
newtonmenu_orientation_changed (XfcePanelPlugin *plugin,
                            GtkOrientation   orientation,
                            newtonmenuPlugin    *newtonmenu)
{
  g_return_if_fail(newtonmenu != NULL);
  g_return_if_fail(GTK_IS_BOX(newtonmenu->button_box));

  gtk_orientable_set_orientation(GTK_ORIENTABLE(newtonmenu->button_box), orientation);
  newtonmenu_update_display(newtonmenu);
}

static gboolean
newtonmenu_size_changed (XfcePanelPlugin *plugin,
                     gint             size,
                     newtonmenuPlugin    *newtonmenu)
{
  GtkOrientation orientation;

  g_return_val_if_fail(newtonmenu != NULL, TRUE);

  orientation = xfce_panel_plugin_get_orientation (plugin);

  if (orientation == GTK_ORIENTATION_HORIZONTAL)
    gtk_widget_set_size_request (GTK_WIDGET (plugin), -1, size);
  else
    gtk_widget_set_size_request (GTK_WIDGET (plugin), size, -1);


  newtonmenu_update_display(newtonmenu);
  return TRUE;
}

static void
on_about_this_pc_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    // The user_data is now newtonmenuPlugin*
    execute_command("xfce4-about");
}

static void
on_system_settings_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    // The user_data is now newtonmenuPlugin*
    execute_command("xfce4-settings-manager");
}

static void
on_run_command_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    // The user_data is now newtonmenuPlugin*
    execute_command("xfce4-appfinder --collapsed");
}

static void
on_force_quit_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    newtonmenuPlugin *newtonmenu = (newtonmenuPlugin*)user_data; // Explicit cast for clarity

    g_return_if_fail(newtonmenu != NULL);

    GtkWindow *parent_window = NULL;
    if (newtonmenu->plugin && gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin))) {
        parent_window = GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin)));
    }

    newtonmenu_show_force_quit_applications_dialog(parent_window, newtonmenu);
}

static void
on_sleep_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    // The user_data is now newtonmenuPlugin*
    execute_command("xfce4-session-logout --suspend");
}

static void
on_restart_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    newtonmenuPlugin *newtonmenu = (newtonmenuPlugin*)user_data;
    GtkWindow *parent_window = NULL;

    g_return_if_fail(newtonmenu != NULL);

    if (newtonmenu->plugin && gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin))) {
        parent_window = GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin)));
    }

    if (newtonmenu->confirm_restart_prop) {
        newtonmenu_show_generic_confirmation(parent_window, _("restart"), _("Restart"), "xfce4-session-logout --reboot");
    } else {
        execute_command("xfce4-session-logout --reboot");
    }
}

static void
on_shutdown_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    newtonmenuPlugin *newtonmenu = (newtonmenuPlugin*)user_data;
    GtkWindow *parent_window = NULL;

    g_return_if_fail(newtonmenu != NULL);

    if (newtonmenu->plugin && gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin))) {
        parent_window = GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin)));
    }
    
    if (newtonmenu->confirm_shutdown_prop) {
        newtonmenu_show_generic_confirmation(parent_window, _("shut down"), _("Shut Down"), "xfce4-session-logout --halt");
    } else {
        execute_command("xfce4-session-logout --halt");
    }
}

static void
on_lock_screen_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    // The user_data is now newtonmenuPlugin*
    execute_command("xflock4");
}

static void
on_log_out_activate(GtkMenuItem *menuitem, gpointer user_data)
{
    newtonmenuPlugin *newtonmenu = (newtonmenuPlugin*)user_data;
    GtkWindow *parent_window = NULL;
    const gchar *username = g_get_user_name();
    gchar *action_name; 

    g_return_if_fail(newtonmenu != NULL);

    if (newtonmenu->plugin && gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin))) {
        parent_window = GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(newtonmenu->plugin)));
    }

    if (username) {
        action_name = g_strdup_printf(_("Log Out %s..."), username); 
    } else {
        action_name = g_strdup(_("Log Out...")); 
    }

    if (newtonmenu->confirm_logout_prop) {
        newtonmenu_show_generic_confirmation(parent_window, action_name, _("Log Out"), "xfce4-session-logout --logout");
    } else {
        execute_command("xfce4-session-logout --logout");
    }
    g_free(action_name);
}

// Function to create the static Newton Menu items (as a GMenu)
static GMenu*
newtonmenu_create_static_newton_menu(newtonmenuPlugin *newtonmenu)
{
    GMenu *static_menu = g_menu_new();
    GMenuItem *menu_item;

    // About This PC
    menu_item = g_menu_item_new_with_label (_("About This PC"));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_about_this_pc_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);

    g_menu_append_section(static_menu, NULL, g_menu_new_from_markup("<section><item><attribute name='label' translatable='yes'>-</attribute></item></section>")); // Simple separator

    // System Settings
    menu_item = g_menu_item_new_with_label (_("System Settings..."));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_system_settings_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);

    // Run Command
    menu_item = g_menu_item_new_with_label (_("Run Command..."));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_run_command_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);
    
    g_menu_append_section(static_menu, NULL, g_menu_new_from_markup("<section><item><attribute name='label' translatable='yes'>-</attribute></item></section>"));

    // Force Quit
    menu_item = g_menu_item_new_with_label (_("Force Quit..."));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_force_quit_activate), newtonmenu); 
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);

    g_menu_append_section(static_menu, NULL, g_menu_new_from_markup("<section><item><attribute name='label' translatable='yes'>-</attribute></item></section>"));

    // Session Management
    menu_item = g_menu_item_new_with_label (_("Sleep"));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_sleep_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);
    
    menu_item = g_menu_item_new_with_label (_("Restart..."));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_restart_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);

    menu_item = g_menu_item_new_with_label (_("Shut Down..."));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_shutdown_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);
    
    g_menu_append_section(static_menu, NULL, g_menu_new_from_markup("<section><item><attribute name='label' translatable='yes'>-</attribute></item></section>"));

    menu_item = g_menu_item_new_with_label (_("Lock Screen"));
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_lock_screen_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);

    // Logout
    const gchar* username = g_get_user_name();
    gchar* logout_label;
    if (username) {
        logout_label = g_strdup_printf(_("Log Out %s..."), username);
    } else {
        logout_label = g_strdup(_("Log Out..."));
    }
    menu_item = g_menu_item_new_with_label (logout_label);
    g_free(logout_label);
    g_signal_connect (G_OBJECT(menu_item), "activate", G_CALLBACK (on_log_out_activate), newtonmenu);
    g_menu_append_item(static_menu, menu_item);
    g_object_unref(menu_item);
    
    return static_menu;
}

// Function to create a fallback "Desktop" menu model
static GMenuModel*
newtonmenu_create_desktop_menu_model(void)
{
    GMenu *desktop_menu = g_menu_new();
    GMenuItem *menu_item;

    menu_item = g_menu_item_new_with_label (_("Desktop Settings"));
    // You can connect actions here for desktop settings if desired
    // Example: Launch xfce4-display-settings
    g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(execute_command), g_strdup("xfce4-display-settings"));
    g_menu_append_item(desktop_menu, menu_item);
    g_object_unref(menu_item);

    menu_item = g_menu_item_new_with_label (_("File Manager"));
    // Example: Launch Thunar
    g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(execute_command), g_strdup("thunar"));
    g_menu_append_item(desktop_menu, menu_item);
    g_object_unref(menu_item);

    menu_item = g_menu_item_new_with_label (_("Web Browser"));
    // Example: Launch default web browser
    g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(execute_command), g_strdup("xdg-open https://www.xfce.org/"));
    g_menu_append_item(desktop_menu, menu_item);
    g_object_unref(menu_item);

    return G_MENU_MODEL(desktop_menu);
}


void
newtonmenu_update_combined_menu (newtonmenuPlugin *newtonmenu)
{
    GMenu *new_combined_menu_builder = g_menu_new();
    GMenuModel *dynamic_menu_source = NULL;
    gchar *dynamic_menu_title_label = NULL;

    g_return_if_fail(newtonmenu != NULL);

    // 1. Add static Newton menu items as the first section
    if (newtonmenu->static_newton_menu) {
        g_menu_append_section(new_combined_menu_builder, NULL, G_MENU_MODEL(newtonmenu->static_newton_menu));
    }
    
    // 2. Determine the dynamic menu source (application or desktop)
    if (newtonmenu->app_menu_model) {
        dynamic_menu_source = G_MENU_MODEL(newtonmenu->app_menu_model); // Cast to generic GMenuModel
        
        if (newtonmenu->hide_application_name_prop) {
            // Hide app name: use custom title or generic "Applications"
            dynamic_menu_title_label = g_strdup(newtonmenu->global_menu_title_prop);
            if (!dynamic_menu_title_label || strlen(dynamic_menu_title_label) == 0) {
                dynamic_menu_title_label = g_strdup(_(DEFAULT_GLOBAL_MENU_TITLE));
            }
        } else {
            // Show app name: try to get it from the app_menu_model's root item
            gchar *app_label = NULL;
            // DbusmenuClient's root item (ID 0) often has the application name in 'label' property
            // Or 'org.appmenu.Label' for Unity-style appmenus
            GVariant *app_root_properties = dbusmenu_client_get_item_properties(newtonmenu->app_menu_model, 0, NULL);
            if (app_root_properties) {
                // Try common properties for application label
                GVariant *label_variant = g_variant_lookup_value(app_root_properties, "org.appmenu.Label", G_VARIANT_TYPE_STRING); // Unity-style
                if (!label_variant) {
                    label_variant = g_variant_lookup_value(app_root_properties, DBUSMENU_MENUITEM_PROP_LABEL, G_VARIANT_TYPE_STRING); // Standard dbusmenu
                }
                
                if (label_variant) {
                    app_label = g_strdup(g_variant_get_string(label_variant));
                    g_variant_unref(label_variant);
                }
                g_variant_unref(app_root_properties);
            }
            // Fallback to active window title if no D-Bus label found
            if (!app_label && newtonmenu->active_wnck_window) {
                app_label = g_strdup(wnck_window_get_name(newtonmenu->active_wnck_window));
            }
            
            // Format application name for display. Use Pango markup for bolding.
            dynamic_menu_title_label = app_label ? g_markup_printf_escaped("<b>%s</b>", app_label) : g_strdup(_("Application"));
            g_free(app_label); // Free the temporary app_label
        }
    } else {
        // No active application menu: use desktop menu as fallback
        dynamic_menu_source = newtonmenu_create_desktop_menu_model();
        dynamic_menu_title_label = g_strdup(_("Desktop")); // Always show "Desktop" for this fallback
    }

    // 3. Append the dynamic menu as a submenu
    if (dynamic_menu_source && dynamic_menu_title_label) {
        g_menu_append_submenu(new_combined_menu_builder, dynamic_menu_title_label, dynamic_menu_source);
        g_object_unref(dynamic_menu_source); // Transfer ownership to new_combined_menu_builder
    }
    g_free(dynamic_menu_title_label);

    // 4. Update the combined menu model on the GtkMenuButton
    if (newtonmenu->combined_menu_model) {
        g_object_unref(newtonmenu->combined_menu_model);
    }
    newtonmenu->combined_menu_model = g_object_ref(new_combined_menu_builder); // Reference for storage
    gtk_menu_button_set_menu_model(newtonmenu->button, newtonmenu->combined_menu_model);

    g_object_unref(new_combined_menu_builder); // The GMenu object is now owned by the GtkMenuButton
}


// This function will be triggered by GtkMenuButton's "map" signal
// to handle autohide blocking when the menu pops up.
static void
newtonmenu_popup_menu_on_toggle (GtkMenuButton *button, newtonmenuPlugin *newtonmenu)
{
    g_return_if_fail (newtonmenu != NULL);
    g_return_if_fail (GTK_IS_MENU_BUTTON (button));

    // The GtkMenuButton's popup is about to be shown (or is shown).
    // Block panel autohide.
    xfce_panel_plugin_block_autohide (newtonmenu->plugin, TRUE);
}

// This function will be triggered by GtkMenuButton's "unmap" signal
// to handle autohide unblocking when the menu disappears.
static void
newtonmenu_menu_deactivate_cb (GtkMenuButton *button, newtonmenuPlugin *newtonmenu)
{
    g_return_if_fail (newtonmenu != NULL);
    g_return_if_fail (GTK_IS_MENU_BUTTON (button));

    // The GtkMenuButton's popup has disappeared.
    // Unblock panel autohide.
    xfce_panel_plugin_block_autohide (newtonmenu->plugin, FALSE);
}


static void
newtonmenu_construct (XfcePanelPlugin *plugin)
{
  newtonmenuPlugin *newtonmenu;

  xfce_textdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR, "UTF-8");
  newtonmenu = newtonmenu_new (plugin);
  g_return_if_fail(newtonmenu != NULL);

  gtk_container_add (GTK_CONTAINER (plugin), newtonmenu->event_box);
  xfce_panel_plugin_add_action_widget (plugin, newtonmenu->event_box);
  
  g_signal_connect (G_OBJECT (plugin), "free-data", G_CALLBACK (newtonmenu_free), newtonmenu);
  g_signal_connect (G_OBJECT (plugin), "save", G_CALLBACK (newtonmenu_save), newtonmenu);
  g_signal_connect (G_OBJECT (plugin), "size-changed", G_CALLBACK (newtonmenu_size_changed), newtonmenu);
  g_signal_connect (G_OBJECT (plugin), "orientation-changed", G_CALLBACK (newtonmenu_orientation_changed), newtonmenu);
  
  // Connect map/unmap signals to handle panel autohide for GtkMenuButton's popup
  // These are connected here as it's the `xfce_panel_plugin_add_action_widget` call
  // that typically makes the plugin fully visible and interactive on the panel.
  g_return_if_fail(newtonmenu->button != NULL);
  g_signal_connect (G_OBJECT (newtonmenu->button), "map", G_CALLBACK (newtonmenu_popup_menu_on_toggle), newtonmenu);
  g_signal_connect (G_OBJECT (newtonmenu->button), "unmap", G_CALLBACK (newtonmenu_menu_deactivate_cb), newtonmenu);

  xfce_panel_plugin_menu_show_configure (plugin);
  g_signal_connect (G_OBJECT (plugin), "configure-plugin", G_CALLBACK (newtonmenu_configure), newtonmenu);
  xfce_panel_plugin_menu_show_about (plugin);
  g_signal_connect (G_OBJECT (plugin), "about", G_CALLBACK (newtonmenu_about), plugin);
}


// --- New functions for D-Bus / WNCK integration ---

static void
newtonmenu_init_dbus_and_wnck(newtonmenuPlugin *newtonmenu)
{
    GError *error = NULL;

    // Initialize WnckScreen to monitor active window changes
    // WNCK_I_KNOW_THIS_IS_UNSTABLE is required for direct libwnck API access.
    newtonmenu->wnck_screen = wnck_screen_get_default();
    newtonmenu->wnck_active_window_changed_handler_id = g_signal_connect(
        newtonmenu->wnck_screen, "active-window-changed",
        G_CALLBACK(on_wnck_active_window_changed), newtonmenu);

    // Initialize D-Bus session bus connection
    newtonmenu->dbus_session_bus = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &error);
    if (!newtonmenu->dbus_session_bus) {
        g_warning("Failed to connect to D-Bus session bus: %s", error ? error->message : "Unknown error");
        g_clear_error(&error);
        return;
    }

    // Create a D-Bus proxy for the AppMenu Registrar
    newtonmenu->appmenu_registrar_proxy = g_dbus_proxy_new_sync(
        newtonmenu->dbus_session_bus,
        G_DBUS_PROXY_FLAGS_NONE,
        NULL, // GDBusInterfaceInfo (optional, inferred from XML by gdbus-codegen)
        APPMENU_REGISTRAR_BUS_NAME,
        APPMENU_REGISTRAR_OBJECT_PATH,
        APPMENU_REGISTRAR_INTERFACE_NAME,
        NULL, // GCancellable
        &error);
    
    if (!newtonmenu->appmenu_registrar_proxy) {
        g_warning("Failed to create AppMenu Registrar D-Bus proxy: %s", error ? error->message : "Unknown error");
        g_clear_error(&error);
        g_object_unref(newtonmenu->dbus_session_bus);
        newtonmenu->dbus_session_bus = NULL;
        return;
    }

    // Connect signals to listen for window registration/unregistration from the Registrar
    // We use a single callback for both for simplicity, distinguishing by signal_name
    newtonmenu->appmenu_registrar_registered_handler_id = g_signal_connect(
        newtonmenu->appmenu_registrar_proxy, "g-signal", // Generic "g-signal" to catch all signals
        G_CALLBACK(on_appmenu_registrar_signal), newtonmenu);
    newtonmenu->appmenu_registrar_unregistered_handler_id = newtonmenu->appmenu_registrar_registered_handler_id; // Same handler ID, will check signal name in callback

    // Trigger initial menu update based on currently active window
    // This will fetch the menu for the current active window (if any) or default to desktop menu
    on_wnck_active_window_changed(newtonmenu->wnck_screen, NULL, newtonmenu);
}

static void
newtonmenu_teardown_dbus_and_wnck(newtonmenuPlugin *newtonmenu)
{
    if (newtonmenu->wnck_active_window_changed_handler_id > 0) {
        g_signal_handler_disconnect(newtonmenu->wnck_screen, newtonmenu->wnck_active_window_changed_handler_id);
        newtonmenu->wnck_active_window_changed_handler_id = 0;
    }
    if (newtonmenu->wnck_screen) {
        g_object_unref(newtonmenu->wnck_screen);
        newtonmenu->wnck_screen = NULL;
    }
    if (newtonmenu->active_wnck_window) {
        g_object_unref(newtonmenu->active_wnck_window);
        newtonmenu->active_wnck_window = NULL;
    }

    // Only disconnect the signal once since it's the same handler ID for both
    if (newtonmenu->appmenu_registrar_registered_handler_id > 0) {
        g_signal_handler_disconnect(newtonmenu->appmenu_registrar_proxy, newtonmenu->appmenu_registrar_registered_handler_id);
        newtonmenu->appmenu_registrar_registered_handler_id = 0;
        newtonmenu->appmenu_registrar_unregistered_handler_id = 0; // Clear both for clarity
    }
    if (newtonmenu->appmenu_registrar_proxy) {
        g_object_unref(newtonmenu->appmenu_registrar_proxy);
        newtonmenu->appmenu_registrar_proxy = NULL;
    }
    if (newtonmenu->dbus_session_bus) {
        g_object_unref(newtonmenu->dbus_session_bus);
        newtonmenu->dbus_session_bus = NULL;
    }
    // Clean up app_menu_model explicitly if it's a DbusmenuClient
    if (newtonmenu->app_menu_model) {
        g_object_unref(newtonmenu->app_menu_model);
        newtonmenu->app_menu_model = NULL;
    }
}

// Callback for WnckScreen's active-window-changed signal
static void
on_wnck_active_window_changed (WnckScreen *screen, WnckWindow *prev_active_window, newtonmenuPlugin *newtonmenu)
{
    WnckWindow *current_active_window = wnck_screen_get_active_window(screen);

    // Release previous active window reference
    if (newtonmenu->active_wnck_window) {
        g_object_unref(newtonmenu->active_wnck_window);
        newtonmenu->active_wnck_window = NULL;
    }

    if (current_active_window) {
        newtonmenu->active_wnck_window = g_object_ref(current_active_window);
        g_debug("Wnck: Active window changed to %s (XID: %lu)",
                wnck_window_get_name(current_active_window),
                (gulong)wnck_window_get_xid(current_active_window));
        newtonmenu_fetch_app_menu(newtonmenu, newtonmenu->active_wnck_window);
    } else {
        g_debug("Wnck: No active window. Displaying desktop menu.");
        // No active window, clear app menu model and update combined menu
        if (newtonmenu->app_menu_model) {
            g_object_unref(newtonmenu->app_menu_model);
            newtonmenu->app_menu_model = NULL;
        }
        newtonmenu_update_combined_menu(newtonmenu);
    }
}

// Generic callback for AppMenu Registrar D-Bus signals
static void
on_appmenu_registrar_signal (GDBusProxy *proxy, const gchar *sender_name, const gchar *signal_name, GVariant *parameters, gpointer user_data)
{
    newtonmenuPlugin *newtonmenu = (newtonmenuPlugin*)user_data;

    if (g_strcmp0(signal_name, "WindowRegistered") == 0) {
        guint32 window_id;
        gchar *service_name = NULL;
        gchar *object_path = NULL;

        g_variant_get(parameters, "(uso)", &window_id, &service_name, &object_path);

        // If the registered window is the currently active one, fetch its menu
        if (newtonmenu->active_wnck_window && wnck_window_get_xid(newtonmenu->active_wnck_window) == window_id) {
            g_debug("AppMenu: Registered signal received for active window %lu, service: %s, path: %s", (gulong)window_id, service_name, object_path);
            newtonmenu_fetch_app_menu(newtonmenu, newtonmenu->active_wnck_window);
        } else {
            g_debug("AppMenu: Registered signal received for non-active window %lu", (gulong)window_id);
        }

        g_free(service_name);
        g_free(object_path);
    } else if (g_strcmp0(signal_name, "WindowUnregistered") == 0) {
        guint32 window_id;
        g_variant_get(parameters, "(u)", &window_id);

        // If the unregistered window was the currently active one, clear its menu
        if (newtonmenu->active_wnck_window && wnck_window_get_xid(newtonmenu->active_wnck_window) == window_id) {
            g_debug("AppMenu: Unregistered signal received for active window %lu", (gulong)window_id);
            if (newtonmenu->app_menu_model) {
                g_object_unref(newtonmenu->app_menu_model);
                newtonmenu->app_menu_model = NULL;
            }
            newtonmenu_update_combined_menu(newtonmenu);
        } else {
            g_debug("AppMenu: Unregistered signal received for non-active window %lu", (gulong)window_id);
        }
    }
}

static void
newtonmenu_fetch_app_menu (newtonmenuPlugin *newtonmenu, WnckWindow *window)
{
    GError *error = NULL;
    gchar *service_name = NULL;
    gchar *object_path = NULL;

    g_return_if_fail(newtonmenu != NULL);
    g_return_if_fail(window != NULL);
    g_return_if_fail(newtonmenu->appmenu_registrar_proxy != NULL);

    // Call GetMenuForWindow on the AppMenu Registrar
    GVariant *result = g_dbus_proxy_call_sync(
        newtonmenu->appmenu_registrar_proxy,
        "GetMenuForWindow",
        g_variant_new("(u)", (guint32)wnck_window_get_xid(window)),
        G_VARIANT_TYPE("(so)"),
        G_DBUS_CALL_FLAGS_NONE,
        -1, // timeout
        NULL, // cancellable
        &error);

    if (error) {
        g_warning("Failed to get menu for window %lu from Registrar: %s", (gulong)wnck_window_get_xid(window), error ? error->message : "Unknown error");
        g_clear_error(&error);
        
        // Clear old app menu model and update combined menu with fallback
        if (newtonmenu->app_menu_model) {
            g_object_unref(newtonmenu->app_menu_model);
            newtonmenu->app_menu_model = NULL;
        }
        newtonmenu_update_combined_menu(newtonmenu);
        return;
    }

    g_variant_get(result, "(so)", &service_name, &object_path);
    g_variant_unref(result);

    // Check if the service name and object path are valid (not empty service or root path)
    if (service_name && object_path && strlen(service_name) > 0 && g_strcmp0(object_path, "/") != 0) {
        // A valid menu was returned. Create a DbusmenuClient (which is a GMenuModel)
        if (newtonmenu->app_menu_model) {
            // Disconnect old signal before unreffing, if it exists
            if (newtonmenu->app_menu_model && newtonmenu->app_menu_model->priv) { // Check if priv member exists for DbusmenuClient (internal detail)
                g_signal_handlers_disconnect_by_func(newtonmenu->app_menu_model, G_CALLBACK(newtonmenu_update_combined_menu), newtonmenu);
            }
            g_object_unref(newtonmenu->app_menu_model);
            newtonmenu->app_menu_model = NULL; // Clear existing model reference before new assignment
        }
        newtonmenu->app_menu_model = dbusmenu_client_new(service_name, object_path);
        g_debug("AppMenu: Fetched menu for window %lu from service: %s, path: %s", (gulong)wnck_window_get_xid(window), service_name, object_path);

        // Connect to changes in the app menu model to update the combined menu
        g_signal_connect(newtonmenu->app_menu_model, "items-changed", G_CALLBACK(newtonmenu_update_combined_menu), newtonmenu);
        // The DbusmenuClient automatically fetches the layout on creation if the service is present.
    } else {
        g_debug("AppMenu: No valid menu for window %lu. Service: %s, Path: %s", (gulong)wnck_window_get_xid(window), service_name, object_path);
        if (newtonmenu->app_menu_model) {
            // Disconnect old signal if it exists before unreffing
            if (newtonmenu->app_menu_model->priv) { // Check if priv member exists for DbusmenuClient
                g_signal_handlers_disconnect_by_func(newtonmenu->app_menu_model, G_CALLBACK(newtonmenu_update_combined_menu), newtonmenu);
            }
            g_object_unref(newtonmenu->app_menu_model);
            newtonmenu->app_menu_model = NULL;
        }
    }

    g_free(service_name);
    g_free(object_path);

    // Update the displayed menu regardless of whether an app menu was found
    newtonmenu_update_combined_menu(newtonmenu);
}